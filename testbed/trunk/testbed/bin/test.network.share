#!/bin/bash

# Globals
OPTS="$@"
START=1
END=
CLIENTS=
TEST_OUTPUT_DIR=
TIMES=
BANDWIDTHS=
PLOTS= # default no plots
VERBOSE= # no verbos
DIR_FOR_PLOTS="plots"
HOSTNAME_PREFIX="192.168.2."
STATES_RELATIVE_DIR="states"
TCPDUMP_THROUGHPUT_IN_TIME_START=0
TCPDUMP_THROUGHPUT_IN_TIME_DURATION=20
TCPDUMP_THROUGHPUT_IN_TIME_MAX_PACKETS_SEND=0
IPERF_PORT=5001

usage()
{
prog=`basename $0`
cat << EOF
usage: $prog -d directory -t seconds -b bandwidth -n number [-p] [-v]

This script will run udp test of shering network. It will issue all the clients at the same time to send udp to the access point.
EXAMPLE: $prog  -d test_dir -t "10,20,300" -b "2,4,30" -n 16 -v

OPTIONS:
	-d	directory for results
	-t	times in seconds to test
	-b	bandwidths to test
	-n	number of clients to test together
	-c	clients (just a list of clients eg. "3,16,7,9")
	-p	generate just plots (without running experiment)
	-h	Show this message
	-v 	verbose
EOF
}

check_for_no_opts()
{
	# exit if no arguments
	if [[ -z $OPTS ]]
	then 
		usage
		exit 1
	fi
}

get_opts()
{
	while getopts "d:t:b:n:c:pvh" options; do
		case $options in
			d) TEST_OUTPUT_DIR=$OPTARG;;
			t) TIMES=`echo $OPTARG | tr ',' ' '`;;
			b) BANDWIDTHS=`echo $OPTARG | tr ',' ' '`;;
			n) END=$OPTARG;;
			c) CLIENTS=`echo $OPTARG | tr ',' ' '`;;
			p) PLOTS=1;;
			v) VERBOSE=1;;
			h) usage
			   exit;;
			*) usage
			   exit 1;;
		esac
	done
}

check_for_required_opts()
{
	if [[ -z $TEST_OUTPUT_DIR || -z $TIMES || -z $BANDWIDTHS ]]
	then 
		usage
		exit 1
	fi

	# or clients list or end number of clients
	if [[ -z $END && -z $CLIENTS ]]
	then 
		echo "You should provide -n or -c"
		usage
		exit 1
	fi
}

check_directory()
{
	if [[ -d $TEST_OUTPUT_DIR ]]; then
		echo "Error: directory \"$TEST_OUTPUT_DIR\" exists!"
		echo "I will not write on existing directory."
		exit 1
	fi
}

combine_clients_opts()
{
	if [[ ! -z $END ]]; then
		# we got -n, so we'll convert to $CLIENTS
		CLIENTS=`seq -s ' ' $START $END`
	fi
}

process_options()
{
	check_for_no_opts
	get_opts $OPTS
	check_for_required_opts
	[[ -z $PLOTS ]] && check_directory
	combine_clients_opts
}

# gets string to output and optional options to echo (-n for example)
verbose()
{
	local str=$1
	local options=$2
	if [[ -n $VERBOSE ]]; then
		echo $options $str >&2
	fi
}

make_results_dir()
{
	local t=$1
	local b=$2
	local dir="$TEST_OUTPUT_DIR/time.${t}.bandwidth.${b}"
	mkdir -p $dir
	if [[ -d $dir ]]; then
		echo $dir
	else
		echo "Error: cann't create directory \"$dir\""
		exit 1
	fi
}

wait_for_pids_to_finish()
{
	local pids=$1
	for p in $pids 
	do 
		verbose "Waiting for pid $p"
		local flag=
		while [[ -z $flag ]]; do
			local ret=`ps fax | grep $p | grep -v grep `
			if [[ $? == 0 ]]; then 
				flag=1
			else
				sleep 1
			fi
		done
	done
}

# save the state information of the client
get_client_state()
{
	local dir=$1
	local pids=
	local state_dir="$dir/$STATES_RELATIVE_DIR"
	mkdir -p $state_dir
	
	for c in $CLIENTS
	do 
		verbose "Getting client$c state data"
		ssh root@client$c "ifconfig 2>/dev/null ; iwconfig 2>/dev/null ; iwpriv ath0 2>/dev/null" > $state_dir/client$c.state &
		local pid=`echo $!`
		pids="$pids $pid"
	done

	# wait for jobs to finish
	for p in $pids
	do
		verbose "waiting for client state to arrive - pid $p"
		wait $p
	done
}

run_single_test()
{
	local t=$1
	local b=$2
	local first_run=
	local pids=

	local dir=`make_results_dir $t $b`
	get_client_state $dir
	verbose "Running $t seconds test with $b bandwidth"
	verbose "Running tcpdump on ap"
	ssh root@ap "tcpdump -i ath1 -S -n -tt port 5001 > /tmp/ap.dump" &
	verbose "Running tcpdump on src"
	ssh root@src "tcpdump -i eth0 -S -n -tt port 5001 > /tmp/src.dump" &
	sleep 3
	for c in $CLIENTS
	do 
		verbose "Running iperf on client$c"
		local tput_options="-o -s client$c -u src -d wsrc -t $t -b $b -v"
		if [[ ! -z $first_run ]]; then
			tput_options="$tput_options -k"
		fi
		tput  $tput_options 2>&1 >> $dir/client${c} &
		local pid=`echo $!`
		pids="$pids $pid"
		first_run=1
	done

	# wait for jobs to finish
	for p in $pids
	do
		verbose "waiting for pid $p to finish"
		wait $p
	done
	verbose "kill tcpdump on ap"
	ssh root@ap "killall tcpdump"
	scp root@ap:/tmp/ap.dump $dir/ap.dump
	verbose "kill tcpdump on src"
	ssh root@src "killall tcpdump"
	scp root@src:/tmp/src.dump $dir/src.dump
}

iterate_time_and_bandwidth()
{
	for t in $TIMES
	do
		for b in $BANDWIDTHS
		do
			run_single_test $t $b 
		done
	done
}

kill_iperf_server()
{
	local pid=`ps fax | grep "tput" | grep -v grep | cut -c 0-5`
	kill $pid
}

create_temp_file()
{
	prog_name=`basename $0`
	file_name=`mktemp -t $prog_name.XXXXXX`
	if [[ $? != 0 ]]; then
		echo "can't create temp file"
		exit 1
	fi
	echo $file_name
}

# gets temp file to delete
release_temp_file()
{
	rm -f $1
}

plot_png()
{
	local data_file=$1
	local output_file_name=$2
	local title=$3
	local xlabel=$4
	local ylabel=$5
	local cols=$6
	local plot_tmp_file=`create_temp_file`
	echo "set term png size 400,300" >> $plot_tmp_file
	echo "set title \"$title\"" >> $plot_tmp_file                                                              
	echo "set boxwidth 0.5" >> $plot_tmp_file                                                              
	echo "set xtics 1" >> $plot_tmp_file                                                              
	echo "set style fill solid 0.25 border" >> $plot_tmp_file                                                              
	echo "set xlabel '$xlabel'" >> $plot_tmp_file
	echo "set output '$output_file_name.png'" >> $plot_tmp_file                                                                
	echo "set ylabel '$ylabel'" >> $plot_tmp_file
	echo "plot \"$data_file\" using $cols with boxes title ''" >> $plot_tmp_file
	gnuplot < $plot_tmp_file
	release_temp_file $plot_tmp_file
}

convert_mb_to_kb()
{
	local str=$1
	local num=`echo $str | cut -d ' ' -f 1`
	local scale=`echo $str | cut -d ' ' -f 2`
	if [[ $scale == 'Mbits/sec' || $scale == 'MBytes' ]]; then 
		num=$(echo "$num*1000" | bc)
	fi
	echo $num
}

generate_data_file()
{
	local data_file=$1
	local input_data_directory=$2
	for c in $CLIENTS
	do
		local tmp=`grep bits $input_data_directory/client$c | cut -d ']' -f 3`
		local total=`echo $tmp | cut -d ' ' -f 3-4`
		local bit_per_sec=`echo $tmp | cut -d ' ' -f 5-6`
		bit_per_sec=`convert_mb_to_kb "$bit_per_sec"`
		total=`convert_mb_to_kb "$total"`
		echo "$c $total $bit_per_sec" >> $data_file
	done
}

# will search the tcpdump file for the time that the last station started to send
# then we can consider the experiment as started
# gets tcpdump file
# returns the line number
find_start_of_experiment()
{
	local data_file=$1
	local line=0
	for c in $CLIENTS
	do 
		local new=`first_packet_sent_by_host $data_file "$HOSTNAME_PREFIX$c"`
		[[ $new -gt $line ]] && line=$new
	done
	echo $line
}

# will search the tcpdump file for the time that the first station finished sending
# then we can consider the experiment as finished
# gets tcpdump file
# returns the line number
find_end_of_experiment()
{
	local data_file=$1
	local line=`cat $data_file | wc -l` # max line number 
	for c in $CLIENTS
	do 
		local new=`last_packet_sent_by_host $data_file "$HOSTNAME_PREFIX$c"`
		[[ $new -lt $line ]] && line=$new
		verbose "last packet sent by $HOSTNAME_PREFIX$c is in line $new in the file $data_file"
	done
	echo $line
}

# return line number in tcpdump file
first_packet_sent_by_host()
{
	local data_file=$1
	local pattern=`host_pattern_for_grep $2`
	local second=`grep --max-count=1 "$pattern" $data_file | cut -d '.' -f 1`
	((second++)) # return the next second which every client had at most one second to start
	grep --max-count=1 --line-number "$second" $data_file | cut -d ':' -f 1
}

# return line number in tcpdump file
last_packet_sent_by_host()
{
	local data_file=$1
	local pattern=`host_pattern_for_grep $2`
	local line=`grep "$pattern" $data_file`
	if [[ -n $line ]]; then
		local second=$(grep "$pattern" $data_file | tail -1 | cut -d '.' -f 1)
		#((second--)) # return the previouse second which every client had at least one second to finish
		#verbose "last packet sent in second $second"
		local line_number=`grep --line-number "$second" $data_file | tail -1 | cut -d ':' -f 1`
		echo $((line_number+1))
	else 
		# this is if a station don't have lines in the file
		# return the last line in the file
		local total_lines=$(cat $data_file | wc -l)
		verbose "$total_lines lines in $data_file"
		echo $total_lines
	fi
}

host_pattern_for_grep()
{
	local host=`escape_dots $1`
	echo "$host\..* >.*$IPERF_PORT"
}

escape_dots()
{
	echo $1 | sed 's/\./\\\./g'
}

generate_tcpdump_start_to_end_of_experiment()
{
	local dump_file=$1
	local start_line=`find_start_of_experiment $dump_file`
	local end_line=`find_end_of_experiment $dump_file`
	verbose "chopping $dump_file from $start_line to $end_line" # debug
	tail -n $end_line $dump_file | head -n $((end_line-start_line+1))
}

get_total_packets_sent_by_client()
{
	local data_file=$1
	local pattern=`host_pattern_for_grep $2`
	grep "$pattern" $data_file | cut -d ' ' -f 1 | sort | uniq | wc -l
}

generate_data_file_for_tcpdump_total_mb()
{
	local data_file=$1
	local input_data_directory=$2
	local ap_dump_file=`create_temp_file`
	local src_dump_file=`create_temp_file`
	local experiment_dump_file=`create_temp_file`
	for srv in ap src
	do
		
		local tcp_dump_file="$input_data_directory/$srv.dump"
		local tmp_file=
		if [[ $srv == "ap" ]]; then 
			tmp_file=$ap_dump_file
		else
			tmp_file=$src_dump_file
		fi
		generate_tcpdump_start_to_end_of_experiment $tcp_dump_file > $experiment_dump_file
		for c in $CLIENTS
		do 
			local packets=`get_total_packets_sent_by_client $experiment_dump_file "$HOSTNAME_PREFIX$c"`
			echo "$c $packets" >> $tmp_file
		done
	done

	# check if the files are similar
	diff $ap_dump_file $src_dump_file > /dev/null
	#diff $ap_dump_file $src_dump_file 
	if [[ $? != 0 ]]; then
		# they are not similar
		echo "Error: tcpdump files are not similar!"
	fi
	cat $src_dump_file > $data_file
	release_temp_file $experiment_dump_file
	release_temp_file $src_dump_file
	release_temp_file $ap_dump_file
}

generate_data_file_for_tcpdump_throughput_in_time()
{
	local experiment_dump_file=$1 # tcpdump file that has just the packets of the experiment
	# second inside the experiment you want start showing the progress
	local start_time=$TCPDUMP_THROUGHPUT_IN_TIME_START 
	# for how long the graph will show 
	local duration=$TCPDUMP_THROUGHPUT_IN_TIME_DURATION 
	local max_packets=0
	local first_second=`head -1 $experiment_dump_file | cut -d '.' -f 1`
	local last_second=`tail -1 $experiment_dump_file | cut -d '.' -f 1`

	verbose "$first_second $last_second"
	# if duration is more then the experiment, just contineu to the last_second of the experiment
	[[ $duration -gt $last_second ]] && duration=$last_second

	local data=""
	local counter=$first_second
	while [[ $counter -le $((first_second+duration)) ]]
	do
		data="$data\n$counter $((counter-first_second+1)) " # normalize the seconds to start with 0
		local tmp_file=`create_temp_file`

		# get all packets with time stamp of $second
		grep "^$counter" $experiment_dump_file > $tmp_file
		for c in $CLIENTS
		do 
			local packets=`get_total_packets_sent_by_client $tmp_file "$HOSTNAME_PREFIX$c"`

			# if there is no packets from $c, then put 0
			[[ -z $packets ]] && packets=0
			[[ $packets -gt $max_packets ]] && max_packets=$packets
			data="$data $packets"
		done
		release_temp_file tmp_file
		((counter++))
	done
	TCPDUMP_THROUGHPUT_IN_TIME_MAX_PACKETS_SEND=$max_packets
	echo -e $data
}

generate_tcpdump_plots()
{
	local workdir=$1
	local plot_tmp_file=$2
	local plot_title=$3
	local experiment_dump_file=`create_temp_file`
	local data_dump_file=`create_temp_file`

	generate_tcpdump_start_to_end_of_experiment $workdir/ap.dump > $experiment_dump_file
	generate_data_file_for_tcpdump_throughput_in_time $experiment_dump_file > $data_dump_file
	#cat $data_dump_file # debug

	generate_data_file_for_tcpdump_total_mb $data_dump_file $workdir
	plot_png $data_dump_file "$plot_file_name.tcpdump" "Tcpdump $plot_title" "Clients" "packets sent" "1:2"

	release_temp_file $data_dump_file
	release_temp_file $experiment_dump_file
}

generate_index_file()
{
	local dir=$1
	local html=$dir/index.html
	echo "<html><body>" > $html
	for i in `find $dir/*.png  -name '*png' -exec basename {} \; | sort -n -t t -k 6,6n`
	do
		local image=`basename $i`
		echo "<img align='center' src='$image' alt='' />" >> $html
	done
	echo "</html></body>" >> $html
}

generate_plots()
{
	local t=
	local b=
	local plots_dir=$TEST_OUTPUT_DIR/$DIR_FOR_PLOTS
	mkdir -p $plots_dir

	for t in $TIMES
	do
		for b in $BANDWIDTHS
		do
			local plot_file_name="$plots_dir/iperf.time.$t.bandwidth.${b}m"
			local plot_title="udp\n($CLIENTS -> src)\nDuration:$t Bandwidth:${b}m"
			local workdir="$TEST_OUTPUT_DIR/time.$t.bandwidth.$b"

			local data_file=`create_temp_file`
			generate_data_file $data_file $workdir
			plot_png $data_file "$plot_file_name.total_mb" "Iperf $plot_title" "Clients" "KBytes" "1:2"
			plot_png $data_file "$plot_file_name.kbits_per_sec" "Iperf $plot_title" "Clients" "Kbits/sec" "1:3"
			release_temp_file $data_file

			generate_tcpdump_plots "$workdir" "$plot_file_name" "$plot_title"
		done
	done
	generate_index_file $plots_dir
}

main()
{
	process_options
	if [[ -z $PLOTS ]]; then
		iterate_time_and_bandwidth
	fi
	generate_plots
}
main
